\documentclass{JAC2003}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{url}

%%   VARIABLE HEIGHT FOR THE TITLE BOX (default 35mm)
\setlength{\titleblockheight}{40mm}

\title{FOSS AT CERN: A DEVICE DRIVERS\\
	EXPERIENCE WITH THE LINUX KERNEL}
\author{%
	Juan David Gonz\'alez Cobas, Emilio Garc\'ia Cota,
	Samuel Iglesias Gons\'alvez,\\
	Julian Lewis, Javier Serrano, Manohar Vanga (CERN, Geneva),\\ 
	Alessandro Rubini (GNUDD, Pavia)}

\begin{document}

\maketitle
\begin{abstract}
    We describe the experience acquired during the integration of the
    \texttt{tsi148} driver
    into the main Linux kernel tree. The benefits (and some of the drawbacks) for
    long-term software maintenance are analysed, the most immediate one being the
    support and quality review added by an enormous  community of skilled
    developers. Indirect consequences are also analysed, and these are no less
    important: a serious impact in the style of the development process, the use of
    cutting edge tools and technologies supporting development, the adoption of the
    very strict standards enforced by the Linux kernel community, etc. These
    elements were also exported to the hardware development process in our section
    and we will explain how they were used with a particular example in mind: the
    development of the FMC family of boards following the Open Hardware philosophy,
    and how its architecture must fit the Linux model. This delicate interplay of
    hardware and software architectures is a perfect showcase of the benefits we
    get from  the strategic decision of having our drivers integrated in the
    kernel.  Finally, the case for a whole family of CERN-developed drivers for
    data acquisition models, the prospects for its integration in the kernel, and
    the adoption of a model parallel to Comedi, is also taken as an example of how
    this model will perform in the future.
\end{abstract}


\section{TSI148 DRIVER INTEGRATION IN THE KERNEL}
\subsection{Rationale}
The VME bus is a central component of the Controls System at CERN. We 
rely on 1140 FECs (Front End Computers), 710 of which are VME crates
with SBC (Single Board Computers). A process of renovation is in course,
involving the migration from 
\begin{Itemize}
\item CES RIO2/RIO3 SBCs with PowerPC CPUs runing LynxOS (around 605 crates), to
\item MEN-A20 SBCs with Intel CPUs running  a real-time enabled Linux (around 105)
\end{Itemize}

The MEN-A20 SBC incorporates a TSI148 VME-to-PCI-X bridge chip.
To support the functionalities required, and for maximum backward
comaptibility with the legacy CES API, a device driver was developed 
at CERN group BE/CO in spring 2009. Clearly, this is a strategical
component of the controls system: every VME device relies on the
provided programming interface to the VME bus. The CERN-developed driver
offers, therefore, a CES compatibility API to ease the transition during
the renovation process, and a new API more similar to common practice
in the Linux kernel.

After a period of validation and improvement taking place during 2010,
the strategic decision was taken to submit the driver for
inclusion in the mainline Linux kernel tree. The ongoing process, started
beginning 2011 and in course of completion, is described in the following
sections.

\subsection{Benefits}

There are many reasons that make the insertion of code in the mainline
kernel a desirable target.

\begin{Itemize}
\item Smoother maintenance in the (rather frequent) event of kernel API
    modification.
\item Very strict process of peer review of the code by knowledgeable
    and specialized maintainers.
\item Widespread distribution of the codebase, which can then be
    enhanced and get contributions by many other members of the community.
\item Faster cycle of bug fixes.
\item Being able to drive a critical hardware component with software
    in the stock kernel, with no local, idiosyncratic modifications.
\end{Itemize}

It is an interesting fact that the latter, which looks like a very
far-fetched reason for undertaking this project, turned out to be more
relevant as the process evolved. Renovated FECs at CERN controls system
are diskless machines, booting a custom kernel carefully configured and
patched to match local needs. Though this kernel is essentially a stock,
mainline tree from \url{http://kernel.org} with a very reduced 
configuration, the \verb|CONFIG_PREEMPT_RT|
patch set applied, plus many required local
tweaks, maintaining this system soon becomes a full time job requiring
great expertise and care, given its radical impact in the controls
system stability. The ability of relying on a stock kernel from a main
distribution alleviates this dependency on a dedicated maintainer, and
pushes strongly towards having the \texttt|tsi148| driver integrated
upstream.

\subsection{Drawbacks}

Some of the drawbacks herewith enumerated will be elaborated further in
the description of the integration process, but we summarize here the
most important ones.

\begin{Itemize}
\item It's hard. One should be ready for the peculiar culture of the
    Linux Kernel Mailing List.
\item Design, APIs and coding practice that is common or acceptable at
    CERN must possibly be adapted or completely rebuilt to comply with the
    strict standards of the Linux kernel development community. The morale
    is that the end product will almost certainly be different from what one
    initially settled for (but will also certainly be better).
\item One must be prepared to compromise. The most practical,
    short-lived solution might not be the technically perfect one kernel
    maintainers aim at.
\item Maintainers are occasionally hard to deal with.
\item The process may be long.
\item Gradual changes are likely to be better accepted that big chunks
    of code submitted out of the blue.  
\item Having a history of prior contributions gives more respectability
    and ease of acceptance.
\end{Itemize}

\subsection{The process}

Submission of source code for acceptance in the kernel is done by means
of patches. A fist attempt of integration of the \verb|tsi148| driver
was initiated in mid-2010 by one of the authors (Emilio Garc\'ia
Cota). 

By that time, there existed one \verb|tsi148| driver in the
\texttt{staging/} area of the kernel, maintained by Martyn Welch. This
driver brings a temptative support for the VME bus that covers
two VME-to-PCI bridges:
\begin{Itemize}
\item the Tundra Universe chips, with work derived from VMELinux by John
Huggins and Michael Wyrick.
\item the Tundra TSI148 chip, inspired in the above.
\end{Itemize}

The set of patches initially submitted provided improvements in several
areas, mainly in closer compliance with Linux bus/device model.
Acceptance by the maintainer was partial, and mainly unrelated to core
system issues like the device model.

The submission was re-approached beginning 2011 by another of the
authors (Manohar Vanga). In this case, some bugs in the staging driver
were fixed, and the bulk of modifications concerning the device model
were partially acknowledged. This led to a third iteration of the
process, and the re-issue of a third patch set in August 2011. At the
time of this writing, the definitive submission and acceptance of the
last set of patches (five changesets) is in its final stage, and
will be applied by the main kernel maintainer in the next merge window.

\subsection{Current position}

At the time of this writing, the whole set of patches concerning bug
fixes and device model of the \verb|tsi148| VME bridge driver is
about to be finally accepted. There is still a long way before reaching
the final desideratum, i.e., getting the \verb|tsi148|
supported in a standard way in the mainline kernel tree.
\begin{Itemize}
\item The most important target should be now getting the VME driver out
of the \verb|./staging/| tree. For that purpose, code must be worked on
(or it'll die), and set up to the highest standard of quality to be
accepted in the mainline.
\item There are differences in API that make the merge incompatible with
the API currently used at CERN. This implies the implementation of
a transient 
kernel module acting as adaptor if driver code has to be left untouched.
\end{Itemize}

\section{DRIVERS FOR THE FMC FAMILY}

\begin{table*}[bt]
   \centering
   \caption{BE/CO data acquisition modules}
   \begin{tabular}{llllll}
       \toprule
	\textbf{Module}& \textbf{Type}& \textbf{Channels}& 
	\textbf{Resolution}& \textbf{Speed}& \textbf{Bus} \\ 
       \midrule
	VMOD-12E8/16    & Analog output& 8/16ch& 12b   & 15us/conv& VME/PCI  \\
	VD80            & Analog input & 16ch  & 16b   & 200kS/s&   VME  \\
	SIS3300         & Analog input & 8ch   & 12/14b& 100MS/s&   VME  \\
	SIS3302         & Analog input & 8ch   & 16b   & 100MS/s&   VME  \\
	SIS3320         & Analog input & 8ch   & 12b   & 250MS/s&   VME  \\
	``Fast'' FMC ADC& Analog input & 4ch   & 14b   & 100Ms/s&   VME/PCIe (Wishbone)  \\
	``Slow'' FMC ADC& Analog input & 8ch   & 16b   & 100kS/s&   VME/PCIe (Wishbone)  \\
       \bottomrule
   \end{tabular}
   \label{zio-modules}
\end{table*}

In~\cite{fpga-fmc}, a family of carrier/mezzanine boards compliant 
with the ANSI VITA~57 FMC standard~\cite{vita-fmc} is described. This kit of boards,
developed by the BE/CO Hardware and Timing section at CERN is
another case in point for the benefits of a Linux kernel-centric
approach. The hardware concept and architecture are described
in the aforementioned paper~\cite{fpga-fmc}; the key point is that the
mezzanine provides the basic circuitry, and the core of the application
logic is implemented in the FPGA of the carrier board. The cores inside
this FPGA are interconnected via a Wishbone~\cite{wishbone-spec} bus.

\begin{figure}[tb]
   \centering
   \includegraphics*[width=80mm]{block_diagram.eps}
   \caption{Block diagram of the FMC slow ADC application}
   \label{slow-adc}
\end{figure}

From the software
point of view, a particular instance of this family behaves like a
PCI-to-Wishbone or VME-to-Wishbone bridge. The Wishbone bus
interconnects a set of cores providing functionalities that are either
common to the whole family of mezzanines, or specific to the application
board actually plugged in the FMC slot. We show in figure~\ref{slow-adc}
the block diagram of the FMC 100MS 14 bit ADC,
a typical example of an FPGA application comprising cores for, among
others
\begin{Itemize}
\item basic I${}^2$C interfacing to the mezzanine board
\item Wishbone mastering
\item DMA access to DDR3 memory in the carrier board
\item mezzanine-specific control logic (e.g., ADC programming/setup)
\item interrupt control
\end{Itemize}
The consequence of this modular design of the application FPGA is that
the device driver architecture reflects the structure of this set of
cores (see figure~\ref{wishbone-enum}). The driver for the carrier board
performs essentially the following basic functions
\begin{Itemize}
\item Identify the carrier board and initialize it
\item Perform a basic identification of the mezzanine(s) installed in
    the FMC slot(s), and their configured applications.
\item Load the application firmware into the carrier FPGA
\item Register a Wishbone bus with the kernel
\item Enumerate the cores in that firmware (to make things clear, the
    blocks in figure~\ref{slow-adc})
\item register the devices those cores implement and install the drivers 
    associated to them
\end{Itemize}
The process is a straightforward translation of the Linux kernel device
model as described in~\cite{device-model} or in chapter~14
of~\cite{rubini}. Conceptually, it amounts to a bus driver for the
Wishbone bus, plus a PCI-to-Wishbone bridge driver for the carrier
board.
\begin{figure}[tb]
   \centering
   \includegraphics*[width=80mm]{wishbone-enum.eps}
   \caption{Wishbone bus driver architecture}
   \label{wishbone-enum}
\end{figure}

Modularity and reusability of cores and drivers are not the only
rationales behind this design. Actually, the drivers for the FMC family
are the second family of drivers planned to be integrated in the
mainline kernel. Given that boards and their applications will be
company-produced and available to a wide public (not only CERN-centric),
having their drivers and the Wishbone bus integrated is the logical step
to take. The Wishbone enumeration is made possible through the
definition of an FPGA configuration space developed
in~\cite{fpga-config-space}, that will be the basis for the integration of
all drivers of this family in the kernel.

\section{DATA ACQUISITION DRIVERS: KERNEL FRAMEWORKS}

The third family of drivers considered for integration upstream is less
homogeneous than the FMC family. The BE/CO group supports a standard kit
of hardware modules for data acquisition, some of whose characteristics
can be compared in table~\ref{zio-modules}


\section{PLANS FOR THE FUTURE}
\section{ACKNOWLEDGEMENTS}


\begin{thebibliography}{9}   % Use for  1-9  references
%\begin{thebibliography}{99} % Use for 10-99 references

\bibitem{fpga-fmc}
P. Alvarez, M. Cattin, J. H. Lewis, J. Serrano, T. Wlostowski,
``FPGA Mezzanine Cards for CERN’s Accelerator Control System'',
ICALEPCS'09, Kobe, October 2009, WEB002, p.~376,
\url{http://www.JACoW.org}.

\bibitem{vita-fmc}
VME International Trade Association,
``FPGA Mezzanine Card (FMC) Standard'', \url{http://www.vita.com/}

\bibitem{wishbone-spec}
OpenCORES,
``Wishbone B4: WISHBONE System-on-Chip (SoC)Interconnection
Architecturefor Portable IP Cores'',
see \url{http://opencores.org/opencores,wishbone}

\bibitem{device-model}
``Linux Kernel Device Model'',
see \url{http://lxr.linux.no/#linux+v3.0.3/Documentation/driver-model/}

\bibitem{rubini}
J. Corbet, A. Rubini, G. Kroah-Hartman, ``Linux Device Drivers'', 3rd
edition. O'Reilly and Associates, Sebastopol, CA, 2005.

\bibitem{fpga-config-space} FPGA config space Open Hardware
Project, see
\url{http://www.ohwr.org/projects/fpga-config-space/}

\end{thebibliography}

\end{document}
